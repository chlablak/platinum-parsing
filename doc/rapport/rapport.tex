\documentclass[10pt,a4paper]{article}
\usepackage[french]{babel}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[left=2.00cm, right=2.00cm, top=2.00cm, bottom=2.00cm]{geometry}
\usepackage{float}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{listings,lstautogobble}

\pagestyle{fancy}

% Entêtes et pieds de page
\lhead{TB: Platinum Parsing}
\chead{}
\rhead{HEIG-VD}
\lfoot{}
\cfoot{\thepage}
\rfoot{}

% Commands
\newcommand{\todo}[1]{\textcolor{red}{TODO: #1}}

% No subsubsection in tableofcontent
\setcounter{tocdepth}{2}

\lstset{
	frame=single,
	numbers=left,
	tabsize=2,
	autogobble=true
}

\begin{document}
	
	% Page de titre
	\title{Platinum Parsing\\
		Travail de Bachelor}
	\author{Patrick Champion\\
		Prof. François Birling}
	\date{Printemps 2017\\
		HEIG-VD}
	\maketitle
	\vspace{6cm}
	\begin{figure}[H]
		\centering
		\todo{inclure logo ici}
	\end{figure}
	\thispagestyle{empty}
	\newpage
	
	% Page vide
	$ $ 
	\thispagestyle{empty}
	\newpage
	
	% Table des matières
	\tableofcontents
	\newpage
	
	\section*{Table des abréviations}
		Dans l'ordre alphabétique:\\
		\begin{itemize}
			\item \textbf{AST} \cite{ast} $\rightarrow$ Abstract Syntax Tree
			\item \textbf{BNF} \cite{bnf} $\rightarrow$ Backus-Naur Form
			\item \textbf{CLI} $\rightarrow$ Command Line Interface
			\item \textbf{EBNF} \cite{ebnf} $\rightarrow$ Extended Backus-Naur Form
			\item \textbf{GOLD} \cite{goldparser} $\rightarrow$ GOLD Parser System
			\item \textbf{LALR} \cite{lalr} $\rightarrow$ Look-Ahead LR parser
			\item \textbf{PP} $\rightarrow$ Platinum Parsing
			\item \textbf{TB} $\rightarrow$ Travail de Bachelor
		\end{itemize}
	\newpage
	
	\section{Introduction}
		\todo{à faire à la fin}
	
	\section{Études des cas d'utilisation}
	\label{sec:etudes-des-cas-d-utilisation}
	
		Afin d'analyser les fonctionnalités nécessaires de PP, nous allons utiliser une approche par cas d'utilisation. La première étape de cette analyse est de définir quels seront les acteurs qui auront besoin d'utiliser notre outil:
		\begin{itemize}
			\item le \textbf{concepteur} de langage veut pouvoir définir sa grammaire EBNF, ainsi que la vérifier (erreur de syntaxe, ambiguïté, etc.)
			\item le \textbf{développeur} de compilateur veut pouvoir se baser sur une grammaire EBNF pour construire facilement les règles de production. Il souhaite également avoir le contrôle sur la sortie produite, cela à l'aide d'un langage riche
			\item le \textbf{mainteneur} du compilateur veut pouvoir apporter des modifications/améliorations au sans devoir revoir tout le processus depuis le début
			\item l'\textbf{utilisateur} du compilateur veut pouvoir l'utiliser simplement, celui-ci devrait aussi optionnellement fournir des options de compilation lui offrant un certain contrôle
		\end{itemize}
		
		À partir de ces acteurs, nous pouvons construire un diagramme des cas d'utilisation de PP:
		\begin{figure}[H]
			\centering
			\todo{revoir les use-cases}%\includegraphics[width=0.5\textwidth]{../diagrams/use-case/use-case}
			\caption{Diagramme des cas d'utilisation}
		\end{figure}
		
		\subsection{Cahier des charges}
			Le diagramme ci-dessus nous offre un bon aperçu des fonctionnalités que nous devons implémenter. Nous allons cependant préciser par écrit celles-ci afin d'avoir un cahier des charges complet. Dans cette section les fonctionnalités utilisant \textit{doit} sont obligatoires, celles utilisant \textit{devrait} sont optionnelles:
			
			\begin{enumerate}
				\item La conception de Platinum Parsing:
				\begin{itemize}
					\item \textbf{doit} amener à un outil capable de remplacer \textit{Gold Parsing System}
					\item \textbf{doit} évaluer et sélectionner les briques technologiques à utiliser pour l'analyse de la BNF, la construction des tables LALR et la génération de code multilangage
					\item devrait être pensée pour avoir une approche générique du problème de la compilation
					\item devrait fournir une documentation complète de la solution
				\end{itemize}
				
				\item Le module d'analyse de grammaire EBNF:
				\begin{itemize}
					\item \textbf{doit} lire et comprendre une grammaire selon la syntaxe EBNF
					\item \textbf{doit} analyser la validité d'une grammaire définie
					\item \textbf{doit} aider à la correction des erreurs de grammaire
					\item \textbf{doit} permettre de tester une grammaire pour la reconnaissance d'un texte en entrée 
				\end{itemize}
				
				\item Le module de génération de tables LALR:
				\begin{itemize}
					\item \textbf{doit} générer les tables selon une grammaire EBNF donnée
					\item \textbf{doit} être capable de traduire les tables selon un modèle fourni par l'utilisateur
					\item devrait fournir une documentation pour l'utilisation des tables générées
				\end{itemize}
				
				\item L'environnement de développement:
				\begin{itemize}
					\item devrait soit être un IDE dédié ou un plugin pour un environnement existant
					\item devrait intégrer l'ensemble des fonctionnalités de Platinum Parsing pour en faciliter l'usage
				\end{itemize}
				
				\item La solution finale:
				\begin{itemize}
					\item \textbf{doit} fournir une démonstration en développant un lexer et un parser en C\# pour le langage ISO CNC
				\end{itemize}
			\end{enumerate}

	\section{Architecture du projet}
		Dans cette section, nous allons poser l'architecture de PP. C'est-à-dire l'organisation générale des différentes fonctionnalités requises, ainsi que leur utilisation dans des cas réels.
	
		\subsection{GOLD Parser System \cite{goldparser}}
			Pour commencer, nous allons voir comment fonctionne GOLD Parser. le but de ce projet étant de remplacer GOLD, il s'agit d'un bon point de départ. En effet nous souhaitons proposer la même chose et, éventuellement, aller plus loin encore.\\
			
			Voici le schéma tel qu'expliqué sur le site de GOLD:
			\begin{figure}[H]
				\centering
				\includegraphics[width=0.8\textwidth]{../diagrams/pipeline/pipeline-gold-parser}
				\caption{Fonctionnement de GOLD Parser System}
			\end{figure}
			
			L'utilisation de GOLD se décompose en 2 étapes distinctes:
			\begin{enumerate}
				\item le développeur écrit la grammaire de son langage et utilise le \textit{Builder} pour générer une grammaire compilée (.cgt), constituée principalement des tables (LALR, ...) du langage en question. À partir de là, le \textit{Builder} n'est plus nécessaire
				\item le développeur implémente un \textit{Engine} (dans n'importe quel langage) qui s'occupe de charger la grammaire compilée et d'effectuer le \textit{parsing} des fichiers sources 
			\end{enumerate}
			
			Une des forces de GOLD est que de nombreuses personnes ont fournies une implémentation d'\textit{Engine} dans des langages de programmation différents. Ces \textit{Engine} étaient donc prêts a être utilisés, cela implique que le format du fichier .cgt doit être normalisé.\\
			
			Le désavantage de cette approche est qu'il n'est pas possible de réaliser toute la chaîne en une seule fois.
		
		\subsection{Décomposition en sous-projets}
			Avant de passer à la section suivante, qui explique comment PP sera organisé, nous allons rapidement définir à un niveau plus large quelles seront les différentes parties de PP:
			\begin{figure}[H]
				\centering
				\includegraphics[width=0.8\textwidth,trim={3cm 3cm 3cm 3cm},clip]{../diagrams/pipeline/pipeline-parts}
				\caption{Sous-projets de PP}
			\end{figure}
			
			Si nous partons du plus interne au plus externe, nous avons:
			\begin{itemize}
				\item le \textbf{framework}, qui n'est rien d'autre qu'un cadre de développement pour la création de compilateur. On peut le voir comme une collection de briques pré-créées extensible 
				\item le \textbf{CLI}, pour \textbf{C}ommand \textbf{L}ine \textbf{I}nterface, qui aide à l'utilisation du framework et qui propose d'autres outils spécifiques
				\item l'\textbf{IDE} (ou plugin pour un IDE existant), qui utilise principalement le CLI et qui connaît le framework pour offrir une meilleure expérience de développement\\
			\end{itemize}
			
			Ces explications sont encore assez abstraites et méritent d'être approfondies, cela sera fait dans les prochaines sections. Cependant nous préférons les introduire dès maintenant pour simplifier la lecture et la compréhension.
		
		\subsection{Organisation de Platinum Parsing}
			PP est un outil qui peut se décomposer en plusieurs étapes successives (un \textit{pipeline}), chacune prenant des données en entrée et fournissant d'autres données en sortie pour la prochaine étape du processus. Dans cette section nous allons expliciter quelles sont ces étapes ainsi que les données intermédiaires.\\
			
			Premièrement, définissons ce que nous avons besoin au niveau du framework. Nous voulons pouvoir transformer des fichiers sources en quelque chose d'autre:
			\begin{figure}[H]
				\centering
				\includegraphics[width=0.8\textwidth]{../diagrams/pipeline/pipeline-output} 
				\caption{Sorties possibles d'un exécutable créé avec PP}
			\end{figure}
			
			Nous voyons que ce \textit{quelque chose d'autre} peut prendre plusieurs formes: une interprétation directement, des fichiers transpilés, ou encore d'autres choses (ici en exemple des tables).\\
			
			Comment allons-nous créer cet exécutable? Ce prochain schéma va nous montrer cela, avec les acteurs des cas d'utilisation pour plus de clareté (voir section~\ref{sec:etudes-des-cas-d-utilisation}):
			\begin{figure}[H]
				\centering
				\includegraphics[width=0.8\textwidth]{../diagrams/pipeline/pipeline} 
				\caption{Utilisation de PP pour créer un exécutable}
			\end{figure}
			
			On voit ici apparaître le framework ainsi que le CLI, comment cela fonctionne:
			\begin{enumerate}
				\item le concepteur crée sa grammaire EBNF
				\item le développeur utilise une fonctionnalité du CLI pour transformer la grammaire EBNF dans une grammaire compréhensible par le framework, les \textit{Rules}
				\item le développeur utilise les briques du framework et/ou crée ses propres briques
				\begin{itemize}
					\item c'est typiquement ici que la sortie sera décidée (interprétation, transpilation, etc.)
				\end{itemize}
				\item le développeur utilise le CLI pour créer l'exécutable final
				\item l'utilisateur utilise l'exécutable final\\
			\end{enumerate}
			
			Si l'on met les deux schémas précédents ensemble, nous obtenons:
			\begin{figure}[H]
				\centering
				\includegraphics[width=0.8\textwidth]{../diagrams/pipeline/pipeline-full} 
				\caption{Fonctionnement de PP}
			\end{figure}
			
			Ce schéma fait le parallèle entre GOLD et PP. Là où GOLD s'arrête à la transformation d'une grammaire en tables, PP est plus général et permet de transformer depuis n'importe quelle langage (définissable par les \textit{rules}) vers n'importe quelle sortie.\\
			
			Cependant les fonctionnalités de GOLD sont également intéressantes, et celles-ci peuvent être implémentées à l'aide de notre framework. Nous allons voir cela dans la section suivante.
			
		\subsection{Séparation des fonctionnalités framework/CLI}
			Pour séparer les fonctionnalités prévues entre le framework et le CLI, nous allons nous baser sur plusieurs exemples d'utilisation possible de PP. L'un de ces exemples suivra l'approche de GOLD, afin de prouver que PP est capable de faire la même chose si le développeur le souhaite.\\
			
			Nous avons déjà vu une séparation grâce aux précédents schémas, le reste est vu dans les cas ci-dessous:
			\begin{itemize}
				\item le \textbf{framework}:
				\begin{itemize}
					\item fourni un pipeline de développement pour tout le processus
					\item fourni un ou des \textit{builder}/\textit{engine} pré-définis
					\item fourni la gestion des options en ligne de commande
					\item est extensible pour permettre le changement de son comportement
				\end{itemize}
				\item le \textbf{CLI}:
				\begin{itemize}
					\item fourni des outils pour gérer les fichiers ainsi que l'arborescence dans un projet utilisant le framework
					\item exécute la chaîne de compilation complète du framework
					\item fourni des outils relatifs à l'élaboration d'une grammaire EBNF:
					\begin{itemize}
						\item transformation en \textit{Rules} compréhensibles par le framework
						\item vérification de la grammaire (cohérence, conflit, etc.)
						\item vérification de la grammaire en se basant sur des fichiers sources de ladite grammaire 
					\end{itemize}
					\item fourni un outil pour transformer une EBNF directement en tables (comme GOLD)
				\end{itemize}
			\end{itemize}
			
			\subsubsection{Cas 1: interprétation du langage Lua}
				Avant de commencer ce cas d'utilisation, expliquons rapidement le fonctionnement interne du framework:
				\begin{figure}[H]
					\centering
					\includegraphics[width=0.8\textwidth]{../diagrams/pipeline/pipeline-framework} 
					\caption{Fonctionnement interne du framework (général)}
				\end{figure}
				
				On y retrouve les éléments des schémas précédents:
				\begin{enumerate}
					\item on définit notre grammaire, ce sont les \textit{Rules}
					\item le \textit{Builder}, à l'image de celui de GOLD, créer les tables (LALR, ...) en se basant sur les \textit{Rules}
					\item ces tables sont envoyés à l'\textit{Engine}, ainsi que les fichiers sources à traiter selon ces tables
					\item l'\textit{Engine} génère une sortie\\
				\end{enumerate}
				
				Le framework fourni un squelette pour que le développeur puisse faire ce qu'il veut dans l'\textit{Engine} sans avoir à se soucier de certain détails (le \textit{parser} typiquement).\\
				
				Si l'on revient sur notre cas:
				\begin{enumerate}
					\item on définit la grammaire Lua
					\item on implémente un \textit{Engine} pour interpréter Lua\\
				\end{enumerate}
				
				Et c'est tout! On compile et on peut utiliser notre exécutable.
			
			\subsubsection{Cas 2: transformation d'une grammaire EBNF en grammaire BNF}
				Ce cas ressemble beaucoup au cas précédent:
				\begin{enumerate}
					\item on définit la grammaire EBNF
					\item on implémente un \textit{Engine} pour transformer en BNF
				\end{enumerate}
			
			\subsubsection{Cas 3: transformation d'une grammaire EBNF en tables}
				Ce cas est plus intéressant, en effet il s'agit de la fonctionnalité principale de GOLD. Si nous reprenons le schéma précédent pour l'adapter à ce cas:
				\begin{figure}[H]
					\centering
					\includegraphics[width=0.8\textwidth]{../diagrams/pipeline/pipeline-framework-gold} 
					\caption{Utilisation du framework pour recréer le \textit{Builder} de GOLD}
				\end{figure}
				
				\begin{enumerate}
					\item on définit la grammaire EBNF
					\item on implémente un \textit{Engine} qui sérialise les tables dans un fichier (.cgt pour faire la comparaison avec GOLD)\\
				\end{enumerate}
				
				Ce cas étant une fonctionnalité nécessaire au projet, nous pouvons l'inclure au CLI.
			
			\subsubsection{Cas 4: transformation d'une grammaire EBNF en tables, puis implémentation d'un \textit{engine} en Python}
				Ce cas est une utilisation typique de GOLD, voyons comment cela est fait avec PP:
				\begin{enumerate}
					\item on définit notre grammaire en EBNF
					\item on utilise le CLI pour créer les tables correspondantes (voir cas 3)
					\item on implémente un \textit{Engine} en Python qui utilise les tables\\
				\end{enumerate}
				
				On voit ici que le framework est très général, ainsi les fonctionnalités de GOLD plus spécifiques doivent être implémentées à part (à l'aide du framework) et être intégrées au CLI.

	\section{Technologies}
	
		\subsection{Choix du langage}
			Un choix crucial dans ce projet est le choix du langage de programmation que nous allons utiliser pour implémenter notre solution. Plusieurs langages ont été choisis en début de projet pour être comparés:
			\begin{itemize}
				\item C\# 
				\item F\#
				\item Haskell\\
			\end{itemize}
			
			Pour choisir entre ces différentes options, nous allons nous baser sur plusieurs critères pour lesquels chaque langage sera mis en compétition. Les critères fondamentaux sont éliminatifs, c'est-à-dire qu'un langage qui ne répondrait pas à l'un de ces critères est d'emblée supprimé: 
			\begin{figure}[H]
				\centering
				\begin{tabular}{|c|l|c|c|c|}
					\hline
					\textbf{No} & \textbf{Critère} & \textbf{C\#} & \textbf{F\#} & \textbf{Haskell}\\
					\hline
					\multicolumn{5}{|c|}{\textit{Critères fondamentaux}}\\
					\hline
					1 & Le langage a une communauté active et des ressources sur internet & - & - & Oui\\
					2 & Le langage possède une ou des bibliothèques dans le domaine du \textit{parsing} & - & - & Oui\\
					3 & L'implémentation d'un parser de test simple est aisée & - & - & Oui\\
					\hline\hline
					\multicolumn{2}{|c|}{\textbf{Total}} & - & - & Oui\\
					\hline
				\end{tabular}
				\caption{Critères pour le choix du langage et résultats}
			\end{figure}
			
			Les détails des critères testés se trouvent dans l'annexe \ref{subsec:criteres-testes-pour-le-choix-du-langage}.\\
			
			Le choix est donc... \todo{faire choix}
			
		\subsection{Cadre de développement}
			\todo{git, ...}
			
	\section{Conception}
		\todo{attendre de savoir le langage}

	\section{Conclusion}
		\todo{à faire à la fin}
	
	\section{Annexes}
	
		\subsection{Énoncé original}
			Pour faciliter l'écriture de compilateurs, ce travail de diplôme vise à réaliser un outil complet avec un environnement de développement intégré, permettant :
			\begin{itemize}
				\item d'éditer une grammaire selon une syntaxe de type BNF
				\item d'analyser automatiquement cette BNF, de détecter les erreurs de syntaxe, incohérences et conflits de règles.
				\item de générer dans n'importe quel langage de programmation cible, sur la base d'un template textuel fourni par l'utilisateur, les tables pour le lexer et le parser LALR.\\
			\end{itemize}
			
			Ce travail de diplôme vise à développer un outil capable de remplacer "Gold Parsing System", un outil libre intéressant, mais malheureusement fortement pénalisé par des bugs récurrents. L'IDE sera réalisé sous la forme d'un plugin du logiciel oStudio d'Objectis, avec les technologies très en vogue C\# et WPF. Le générateur de compilateurs sera mis en ligne sur Internet en libre accès, permettant à la communauté Internet de bénéficier gratuitement de cette technologie. 
			
		\subsection{Cahier des charges original}
			Les objectifs du travail sont :
			\begin{itemize}
				\item Analyser et formaliser la liste des fonctionnalités répondant aux besoins des différents types d'utilisateurs dans un cahier des charges fonctionnel.
				\item Concevoir l'architecture de la solution.
				\item Évaluer et sélectionner les briques technologiques à utiliser pour l'analyse de la BNF, la construction des tables LALR et la génération de code multilangage.
				\item Développer le module d'analyse BNF, capable de lire une grammaire selon la syntaxe EBNF, d'analyser la validité de la grammaire définie, d'aider la correction des erreurs et de tester la grammaire pour la reconnaissance d'un texte d'entrée.
				\item Développer un module de génération des tables LALR et capable de les traduire dans un code source selon des modèles fournis par l'utilisateur, ce qui permet de cibler différents langages.
				\item Intégrer l'ensemble dans un environnement de développement à sélectionner pour en faciliter l'usage.
				\item Réaliser une démonstration finale de la solution développée en développant un lexer et un parser pour langage ISO CNC en C\#.
				\item Fournir une documentation de conception et un rapport final du travail réalisé.
			\end{itemize}
			
		\subsection{Table des figures}
			\begingroup
				\renewcommand{\section}[2]{}
				\listoffigures
			\endgroup
			
		\subsection{Critères testés pour le choix du langage}
		\label{subsec:criteres-testes-pour-le-choix-du-langage}
			Cette section contient les détails des différents critères.
		
			\subsubsection{1 - Le langage a une communauté active et des ressources sur internet}
			
			Concernant Haskell, le lien suivant contient tous les pointeurs utiles en ressources: \url{https://www.haskell.org/documentation}. Pour ce qui est de la communauté, les questions et réponses sont quotidiennes sur \textit{stack overflow} ainsi que sur \textit{reddit}. Il y a également un wiki communautaire.
			
			\subsubsection{2 - Le langage possède une ou des bibliothèques dans le domaine du \textit{parsing}}
			
			Concernant Haskell, le lien suivant liste différentes bibliothèques présente pour ce langage: \url{https://wiki.haskell.org/Applications_and_libraries}. Plusieurs outils ou bibliothèques pour le parsing existent et sont listés ici: \url{https://wiki.haskell.org/Applications_and_libraries/Compiler_tools}. De plus ce langage est la base de plusieurs compilateurs, voir: \url{https://wiki.haskell.org/Applications_and_libraries/Compilers_and_interpreters}\\
			
			\todo{C\#, F\#}
			
			\subsubsection{3 - L'implémentation d'un parser de test simple est aisée}
				Comme nous devrons implémenter la grammaire EBNF dans le cadre de ce TB, nous allons créer pour ce test un parser pour une grammaire EBNF simplifiée. Puis nous allons tester ce parser sur le fichier suivant:
				\begin{verbatim}
					grammar=identifier;
					identifier=letter,<letter>,digit;
					letter='a'|'b'|'c';
					digit='1'|'2'|'3';
					<test>='un test',<test>;
					<a2>=<a>,<b>|<b>;
				\end{verbatim}
				
				Pour simplification, nous avons uniquement:
				\begin{itemize}
					\item la définition de règle avec \texttt{=} : \texttt{<rule>=<expr>;}
					\item la concaténation avec \texttt{,} : \texttt{<a>,<b>}
					\item le choix avec \texttt{|} : \texttt{<a>|<b>}
					\item les terminaux entourés par des guillemets simples: \texttt{'a'}
					\item les non-terminaux entourés par \texttt{<>} ou pas
					\item pas de gestion des espaces, tabulations, ...
					\item pas de gestion de la priorité des opérateurs, ni des parenthèses\\
				\end{itemize}
				
				Le parser doit pouvoir sortir l'AST correspondant.\\
				
				Nous allons commencer par l'implémentation en Haskell, celle-ci se trouve dans le dossier \texttt{./trials/haskell-simple-ebnf/}. La taille du module EBNF fait 46 lignes, comprenant l'AST ainsi que le parser. Nous avons utilisé la bibliothèque Parsec \cite{parsec} qui utilise une syntaxe très proche de l'EBNF, ce qui est très pratique. Pour 1 million d'itérations, le parsing prend environ 170ms.\\
				
				\todo{C\#, F\#}
			
	
		\subsection{Références}
			\begingroup
				\renewcommand{\section}[2]{}
				\begin{thebibliography}{9}
					
					\bibitem{bnf} BNF, Backus-Naur form,\\
						\url{https://en.wikipedia.org/wiki/Backus\%E2\%80\%93Naur_form}\\
						
					\bibitem{ebnf} EBNF, Extended Backus-Naur form, used to express a context-free grammar,\\ 
						\url{https://en.wikipedia.org/wiki/Extended\_Backus\%E2\%80\%93Naur_form}\\
					
					\bibitem{goldparser} GOLD Parsing System, GOLD is a free parsing system that you can use to develop your own programming languages, scripting languages and interpreters,\\
						\url{http://www.goldparser.org/}\\
						
					\bibitem{lalr} LALR, Look-Ahead LR parser,\\
						\url{https://en.wikipedia.org/wiki/LALR_parser}
						
				\end{thebibliography}
			\endgroup
	
\end{document}\grid
